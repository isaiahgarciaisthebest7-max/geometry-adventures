<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash JS: Master Edition</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; user-select: none; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #game-container { position: relative; width: 1280px; height: 640px; border: 4px solid #333; box-shadow: 0 0 50px rgba(0,150,255,0.3); }
        canvas { display: block; }
        
        /* HUD */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud-center { display: flex; flex-direction: column; align-items: center; padding-top: 15px; }
        .progress-wrapper { display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.5); padding: 5px 20px; border-radius: 20px; }
        #progress-container { width: 600px; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: #00ff40; box-shadow: 0 0 10px #00ff40; }
        #percent-text { color: white; font-weight: bold; font-size: 18px; text-shadow: 2px 2px #000; }
        #attempt-display { color: white; font-weight: bold; font-size: 42px; text-shadow: 3px 3px #000; margin-top: 20px; opacity: 0; transition: opacity 0.3s; }
        .show-att { opacity: 1 !important; }

        /* MENU */
        #main-menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; overflow-y: auto; }
        .logo { color: white; font-size: 60px; text-shadow: 0 0 15px #0099ff; margin-bottom: 20px; }
        .level-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 20px; }
        .lvl-btn { background: #111; border: 2px solid #444; color: white; padding: 15px 25px; width: 400px; cursor: pointer; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; transition: 0.2s; }
        .lvl-btn:hover { border-color: #00ffff; transform: scale(1.02); background: #1a1a1a; }
        
        #crash-flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 1000; }
        .flash-active { opacity: 0.7 !important; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="1280" height="640"></canvas>
        <div id="crash-flash"></div>
        <div id="hud" style="display: none;">
            <div class="hud-center">
                <div class="progress-wrapper">
                    <div id="progress-container"><div id="progress-fill"></div></div>
                    <div id="percent-text">0%</div>
                </div>
                <div id="attempt-display">ATTEMPT 1</div>
            </div>
        </div>
        <div id="main-menu">
            <h1 class="logo">GEOMETRY JS MASTER</h1>
            <div class="level-grid" id="level-grid"></div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const TICK = 1/60;
    const PHY = { G: 0.85, JUMP: -12.5, SPEED: 9.0, GROUND: 540 };

    let state = { mode: "MENU", curLevel: null, cameraX: 0, attempts: 1, objects: [], levelLen: 0, bgColor: "#0066ff" };
    let player = { x: 350, y: 0, w: 38, h: 38, dy: 0, rot: 0, mode: "CUBE", onGround: false, dead: false, gravDir: 1 };
    let input = { hold: false };
    let lastTime = 0, accumulator = 0;

    const levels = [
        { name: "STEREO MADNESS", color: "#0066ff", diff: "EASY", len: 1 },
        { name: "BACK ON TRACK", color: "#00ccff", diff: "EASY", len: 1.1 },
        { name: "POLARGEIST", color: "#a020f0", diff: "NORMAL", len: 1.2 },
        { name: "DRY OUT", color: "#ff8c00", diff: "NORMAL", len: 1.3 },
        { name: "BASE AFTER BASE", color: "#4B0082", diff: "HARD", len: 1.4 },
        { name: "CAN'T LET GO", color: "#FF0000", diff: "HARD", len: 1.5 },
        { name: "JUMPER", color: "#32CD32", diff: "HARDER", len: 1.6 },
        { name: "TIME MACHINE", color: "#FF1493", diff: "HARDER", len: 1.8 },
        { name: "CYCLES", color: "#00008B", diff: "INSANE", len: 2.0 },
        { name: "ELECTRODYNAMIX", color: "#222", diff: "INSANE", len: 2.5 }
    ];

    const grid = document.getElementById('level-grid');
    levels.forEach((l, i) => {
        grid.innerHTML += `<div class="lvl-btn" onclick="startGame(${i})"><span>${i+1}. ${l.name}</span><span style="color:#0ff">${l.diff}</span></div>`;
    });

    window.onkeydown = (e) => { if(e.code === 'Space' || e.code === 'ArrowUp') input.hold = true; };
    window.onkeyup = (e) => { if(e.code === 'Space' || e.code === 'ArrowUp') input.hold = false; };
    canvas.onmousedown = () => input.hold = true;
    canvas.onmouseup = () => input.hold = false;

    function buildLevel(idx) {
        state.objects = [];
        let x = 1200;
        const l = levels[idx];
        const limit = PHY.SPEED * 60 * 60 * l.len; // ~60s * multiplier
        state.bgColor = l.color;

        while (x < limit) {
            let type = Math.random();
            if (x > 5000 && x % 4000 < 100) {
                const modes = ['SHIP', 'BALL', 'WAVE', 'UFO', 'ROBOT'];
                addObj('portal', x, 0, 60, PHY.GROUND, modes[Math.floor(Math.random() * modes.length)]);
                x += 800;
            }
            if (type < 0.2) addObj('spike', x, PHY.GROUND - 40);
            else if (type < 0.4) { addObj('block', x, PHY.GROUND - 40); addObj('block', x+40, PHY.GROUND - 80); }
            else if (type < 0.5) addObj('spike', x, PHY.GROUND-40, 120, 40); // Triple spike
            x += 400;
        }
        state.levelLen = x + 2000;
    }

    function addObj(t, x, y, w=40, h=40, m=null) { state.objects.push({t, x, y, w, h, m}); }

    function startGame(idx) {
        state.curLevel = idx; state.mode = "PLAYING"; buildLevel(idx); resetPlayer(true);
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        requestAnimationFrame(gameLoop);
    }

    function resetPlayer(full) {
        player.y = PHY.GROUND - player.h; player.dy = 0; player.rot = 0; player.dead = false; player.onGround = true; player.mode = "CUBE"; player.gravDir = 1;
        state.cameraX = 0; if(full) state.attempts = 1; else state.attempts++;
        const att = document.getElementById('attempt-display');
        att.innerText = "ATTEMPT " + state.attempts; att.classList.add('show-att');
        setTimeout(() => att.classList.remove('show-att'), 1500);
    }

    function updatePhysics() {
        if(player.dead) return;
        state.cameraX += PHY.SPEED;

        if(player.mode === "CUBE") {
            player.dy += PHY.G;
            if(player.onGround && input.hold) { player.dy = PHY.JUMP; player.onGround = false; }
            if(!player.onGround) player.rot += 6; else player.rot = Math.round(player.rot/90)*90;
        } else if(player.mode === "SHIP") {
            player.dy += input.hold ? -0.5 : 0.4; player.rot = player.dy * 2;
        } else if(player.mode === "BALL") {
            player.dy += 0.8 * player.gravDir;
            if(player.onGround && input.hold) { player.gravDir *= -1; player.onGround = false; input.hold = false; }
            player.rot += 5 * player.gravDir;
        } else if(player.mode === "WAVE") {
            player.dy = input.hold ? -9 : 9; player.rot = (player.dy > 0) ? 25 : -25;
        } else if(player.mode === "UFO") {
            player.dy += PHY.G; if(input.hold) { player.dy = -10; input.hold = false; }
        } else if(player.mode === "ROBOT") {
            player.dy += PHY.G; if(player.onGround && input.hold) { player.dy = -14; player.onGround = false; }
        }

        player.y += player.dy;
        if(player.y + player.h >= PHY.GROUND) { player.y = PHY.GROUND - player.h; player.dy = 0; player.onGround = true; }
        else if(player.y <= 0) { player.y = 0; player.dy = 0; if(player.mode !== "BALL") crash(); }
        else player.onGround = false;

        const pR = { l: state.cameraX+player.x+10, r: state.cameraX+player.x+player.w-10, t: player.y+10, b: player.y+player.h-10 };
        for(let o of state.objects) {
            if(o.x > pR.r + 200) break;
            if(pR.r > o.x && pR.l < o.x+o.w && pR.b > o.y && pR.t < o.y+o.h) {
                if(o.t === 'spike') crash();
                if(o.t === 'block') { if(player.y - player.dy + player.h <= o.y + 12) { player.y = o.y-player.h; player.dy = 0; player.onGround = true; } else crash(); }
                if(o.t === 'portal') player.mode = o.m;
            }
        }
        if(state.cameraX > state.levelLen) location.reload();
    }

    function crash() { if(player.dead) return; player.dead = true; document.getElementById('crash-flash').classList.add('flash-active'); setTimeout(() => { document.getElementById('crash-flash').classList.remove('flash-active'); resetPlayer(false); }, 400); }

    function drawPlayer() {
        ctx.save();
        ctx.translate(state.cameraX + player.x + 19, player.y + 19);
        ctx.rotate(player.rot * Math.PI / 180);
        ctx.fillStyle = "#00ffff"; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;

        if (player.mode === "CUBE" || player.mode === "ROBOT") {
            ctx.fillRect(-19, -19, 38, 38); ctx.strokeRect(-19, -19, 38, 38);
            ctx.fillStyle = "black"; ctx.fillRect(4, -10, 8, 8); // Face
        } else if (player.mode === "SHIP") {
            ctx.beginPath(); ctx.moveTo(-20, 10); ctx.lineTo(20, 10); ctx.lineTo(0, -15); ctx.closePath(); ctx.fill(); ctx.stroke();
        } else if (player.mode === "BALL") {
            ctx.beginPath(); ctx.arc(0, 0, 19, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-19, 0); ctx.lineTo(19, 0); ctx.stroke();
        } else if (player.mode === "WAVE") {
            ctx.beginPath(); ctx.moveTo(-20, 10); ctx.lineTo(20, 0); ctx.lineTo(-20, -10); ctx.closePath(); ctx.fill(); ctx.stroke();
        } else if (player.mode === "UFO") {
            ctx.beginPath(); ctx.ellipse(0, 0, 25, 12, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.arc(0, -5, 10, Math.PI, 0); ctx.fill();
        }
        ctx.restore();
    }

    function draw() {
        ctx.fillStyle = state.bgColor; ctx.fillRect(0,0,1280,640);
        ctx.fillStyle = "#000"; ctx.fillRect(0, PHY.GROUND, 1280, 100);
        ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.strokeRect(-1, PHY.GROUND, 1282, 1);

        ctx.save(); ctx.translate(-state.cameraX, 0);
        for(let o of state.objects) {
            if(o.x < state.cameraX - 100 || o.x > state.cameraX + 1300) continue;
            if(o.t === 'block') { ctx.fillStyle = "#000"; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = "#fff"; ctx.strokeRect(o.x, o.y, o.w, o.h); }
            else if(o.t === 'spike') { ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.moveTo(o.x, o.y+o.h); ctx.lineTo(o.x+o.w/2, o.y); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.fill(); }
            else if(o.t === 'portal') { ctx.fillStyle = "rgba(255,255,255,0.2)"; ctx.fillRect(o.x, 0, o.w, PHY.GROUND); ctx.fillStyle="white"; ctx.fillText(o.m, o.x, 100); }
        }
        if(!player.dead) drawPlayer();
        ctx.restore();

        let pct = Math.min(100, Math.floor((state.cameraX / state.levelLen) * 100));
        document.getElementById('progress-fill').style.width = pct + "%";
        document.getElementById('percent-text').innerText = pct + "%";
    }

    function gameLoop(t) {
        if(state.mode !== "PLAYING") return;
        accumulator += (t - lastTime) / 1000; lastTime = t;
        while(accumulator >= TICK) { updatePhysics(); accumulator -= TICK; }
        draw(); requestAnimationFrame(gameLoop);
    }
</script>
</body>
</html>
