<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash JS: Ultimate Authentic</title>
    <style>
        body {
            margin: 0; background-color: #050505;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden; user-select: none;
        }
        #game-container {
            position: relative; width: 1280px; height: 640px;
            box-shadow: 0 0 100px rgba(0, 150, 255, 0.2);
            border: 4px solid #333; background-color: #000;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- HUD --- */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud-center { display: flex; flex-direction: column; align-items: center; padding-top: 15px; }
        
        .progress-wrapper { display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.4); padding: 5px 20px; border-radius: 20px; }
        #progress-container {
            width: 500px; height: 10px; background: rgba(255,255,255,0.1);
            border-radius: 5px; overflow: hidden;
        }
        #progress-fill { width: 0%; height: 100%; background: #00ff40; box-shadow: 0 0 10px #00ff40; }
        #percent-text { color: white; font-weight: bold; font-size: 18px; min-width: 50px; text-shadow: 2px 2px 2px #000; }

        #attempt-display { 
            color: white; font-weight: bold; font-size: 38px; 
            text-shadow: 3px 3px #000; margin-top: 20px;
            opacity: 0; transition: opacity 0.2s;
        }
        .show-att { opacity: 1 !important; }

        /* --- MENU --- */
        #main-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(0,0,0,0.9), rgba(0,10,30,0.9));
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        .logo { color: white; font-size: 80px; text-shadow: 0 0 20px #0099ff; margin-bottom: 40px; font-weight: 900; }
        .level-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; }
        .lvl-btn {
            background: #111; border: 2px solid #444; color: white; padding: 25px;
            width: 380px; cursor: pointer; border-radius: 10px; transition: 0.2s;
            display: flex; justify-content: space-between; align-items: center; font-size: 18px;
        }
        .lvl-btn:hover { border-color: #00ffff; transform: scale(1.03); background: #1a1a1a; }

        #crash-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 1000;
        }
        .flash-active { opacity: 0.7 !important; transition: none !important; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="1280" height="640"></canvas>
        <div id="crash-flash"></div>

        <div id="hud" style="display: none;">
            <div class="hud-center">
                <div class="progress-wrapper">
                    <div id="progress-container"><div id="progress-fill"></div></div>
                    <div id="percent-text">0%</div>
                </div>
                <div id="attempt-display">ATTEMPT 1</div>
            </div>
        </div>

        <div id="main-menu">
            <h1 class="logo">GEOMETRY JS</h1>
            <div class="level-grid">
                <div class="lvl-btn" onclick="startGame(0)"><span>STEREO MADNESS</span><span style="color:#0f0">EASY</span></div>
                <div class="lvl-btn" onclick="startGame(3)"><span>DRY OUT</span><span style="color:#ffaa00">HARD</span></div>
                <div class="lvl-btn" onclick="startGame(16)"><span>BLAST PROCESSING</span><span style="color:#f00">HARDER</span></div>
                <div class="lvl-btn" onclick="startGame(19)"><span>DEADLOCKED</span><span style="color:#a0f">DEMON</span></div>
            </div>
        </div>
    </div>

<script>
    /** --- ULTIMATE CORE ENGINE --- **/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TICK = 1/60;
    const PHY = {
        G: 0.82, JUMP: -12.8, SPEED: 8.8, GROUND: 540,
        SHIP_G: 0.38, SHIP_LIFT: -0.50,
        WAVE_SPD: 9.5, BALL_G: 0.85
    };

    let state = { mode: "MENU", curLevel: 0, cameraX: 0, attempts: 1, objects: [], levelLen: 0, bgColor: "#0066ff" };
    let player = { x: 350, y: 0, w: 36, h: 36, dy: 0, rot: 0, mode: "CUBE", onGround: false, dead: false, gravDir: 1 };
    let input = { hold: false };
    let lastTime = 0, accumulator = 0;

    const setHold = (v) => input.hold = v;
    window.onkeydown = (e) => { if(e.code === 'Space' || e.code === 'ArrowUp') setHold(true); };
    window.onkeyup = (e) => { if(e.code === 'Space' || e.code === 'ArrowUp') setHold(false); };
    canvas.onmousedown = () => setHold(true);
    canvas.onmouseup = () => setHold(false);

    /** --- LEVEL ARCHITECT --- **/
    function buildLevel(id) {
        state.objects = [];
        let x = 1200;
        
        // Accurate level scaling (60s to 150s)
        const baseSeconds = 60;
        const multiplier = [1, 1.2, 1.4, 1.8, 2.5][id === 19 ? 4 : (id === 16 ? 3 : (id === 3 ? 1 : 0))];
        const levelLimit = PHY.SPEED * 60 * baseSeconds * multiplier;

        const add = (t, ox, oy, ow=45, oh=45, m=null) => state.objects.push({t, x:ox, y:oy, w:ow, h:oh, m});

        while (x < levelLimit) {
            let rand = Math.random();
            
            if (player.mode === "WAVE") {
                // Hard Wave Sawtooth reference from Deadlocked
                let gapY = 150 + Math.sin(x/500) * 100;
                add('block', x, 0, 100, gapY);
                add('block', x, gapY + 180, 100, 400);
                if(x % 1200 === 0) add('spike', x+30, gapY + 10, 30, 30); // Center spike
                x += 100;
            } else if (player.mode === "SHIP") {
                add('block', x, 0, 50, 150);
                add('block', x, PHY.GROUND - 150, 50, 150);
                x += 450;
            } else {
                // Standard Cube/Ball
                add('block', x, PHY.GROUND - 45, 90, 45);
                if(rand > 0.6) add('spike', x + 200, PHY.GROUND - 45);
                if(rand > 0.8) add('spike', x + 245, PHY.GROUND - 45); // Double spike
                x += 600;
            }

            // Mode Switching Portals
            if (x > 4000 && x % 7000 < 500) {
                const modes = ['WAVE', 'SHIP', 'BALL', 'CUBE'];
                let m = modes[Math.floor(Math.random() * modes.length)];
                add('portal', x, 0, 60, PHY.GROUND, m);
                x += 1000;
            }
        }
        state.levelLen = x + 2000;
    }

    function resetPlayer(full) {
        player.y = PHY.GROUND - player.h; player.dy = 0; player.rot = 0;
        player.dead = false; player.onGround = true; player.gravDir = 1; player.mode = "CUBE";
        state.cameraX = 0;
        if(full) state.attempts = 1; else state.attempts++;
        
        const attDisplay = document.getElementById('attempt-display');
        attDisplay.innerText = "ATTEMPT " + state.attempts;
        attDisplay.classList.add('show-att');
        setTimeout(() => attDisplay.classList.remove('show-att'), 2000);
        
        document.getElementById('percent-text').innerText = "0%";
    }

    function startGame(id) {
        state.curLevel = id;
        state.mode = "PLAYING";
        buildLevel(id);
        resetPlayer(true);
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        requestAnimationFrame(gameLoop);
    }

    function updatePhysics() {
        if(player.dead) return;
        state.cameraX += PHY.SPEED;

        // Gravity Modes
        if(player.mode === "CUBE") {
            player.dy += PHY.G;
            if(player.onGround && input.hold) { player.dy = PHY.JUMP; player.onGround = false; }
            if(!player.onGround) player.rot += 6.5; else player.rot = Math.round(player.rot/90)*90;
        } else if(player.mode === "SHIP") {
            player.dy += input.hold ? PHY.SHIP_LIFT : PHY.SHIP_G;
            player.rot = player.dy * 2.2;
        } else if(player.mode === "WAVE") {
            player.dy = input.hold ? -PHY.WAVE_SPD : PHY.WAVE_SPD;
            player.rot = (player.dy > 0) ? 25 : -25;
        } else if(player.mode === "BALL") {
            player.dy += PHY.BALL_G * player.gravDir;
            if(player.onGround && input.hold) { player.gravDir *= -1; player.onGround = false; input.hold = false; }
            player.rot += 5 * player.gravDir;
        }

        player.y += player.dy;

        // Collision: Floor & Ceiling
        if(player.y + player.h >= PHY.GROUND) { player.y = PHY.GROUND - player.h; player.dy = 0; player.onGround = true; }
        else if(player.y <= 0) { player.y = 0; player.dy = 0; if(player.mode !== "BALL") crash(); else player.onGround = true; }
        else player.onGround = false;

        // Precision Collision (Hitbox Forgiveness)
        const pR = { l: state.cameraX+player.x+10, r: state.cameraX+player.x+player.w-10, t: player.y+10, b: player.y+player.h-10 };
        for(let o of state.objects) {
            if(o.x > pR.r + 200) break;
            if(o.x + o.w < pR.l) continue;

            if(pR.r > o.x && pR.l < o.x+o.w && pR.b > o.y && pR.t < o.y+o.h) {
                if(o.t === 'spike') crash();
                if(o.t === 'block') {
                    // Top detection
                    if(player.y - player.dy + player.h <= o.y + 12) { player.y = o.y - player.h; player.dy = 0; player.onGround = true; }
                    else crash();
                }
                if(o.t === 'portal') player.mode = o.m;
            }
        }
        if(state.cameraX > state.levelLen) location.reload();
    }

    function crash() {
        if(player.dead) return;
        player.dead = true;
        document.getElementById('crash-flash').classList.add('flash-active');
        setTimeout(() => {
            document.getElementById('crash-flash').classList.remove('flash-active');
            resetPlayer(false);
        }, 500);
    }

    function draw() {
        // Dynamic Colors based on level
        ctx.fillStyle = (state.curLevel === 19) ? "#111" : (state.curLevel === 16 ? "#300" : "#0052cc");
        ctx.fillRect(0,0,1280,640);
        ctx.fillStyle = "#000"; ctx.fillRect(0, PHY.GROUND, 1280, 100);
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(-1, PHY.GROUND, 1282, 1);

        ctx.save(); ctx.translate(-state.cameraX, 0);
        for(let o of state.objects) {
            if(o.x < state.cameraX - 100 || o.x > state.cameraX + 1300) continue;
            if(o.t === 'block') { ctx.fillStyle = "#000"; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = "#fff"; ctx.strokeRect(o.x, o.y, o.w, o.h); }
            else if(o.t === 'spike') { ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.moveTo(o.x, o.y+o.h); ctx.lineTo(o.x+o.w/2, o.y); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.fill(); }
            else if(o.t === 'portal') { 
                ctx.fillStyle = "rgba(255,255,255,0.2)"; ctx.fillRect(o.x, 0, o.w, PHY.GROUND);
                ctx.fillStyle = "white"; ctx.font = "bold 20px Arial"; ctx.fillText(o.m, o.x, 100);
            }
        }

        if(!player.dead) {
            ctx.save(); ctx.translate(state.cameraX+player.x+18, player.y+18); ctx.rotate(player.rot*Math.PI/180);
            ctx.fillStyle = "#00ffff"; ctx.fillRect(-18,-18,36,36); ctx.strokeStyle="#fff"; ctx.lineWidth=3; ctx.strokeRect(-18,-18,36,36);
            ctx.restore();
        }
        ctx.restore();

        let pct = Math.min(100, Math.floor((state.cameraX / state.levelLen) * 100));
        document.getElementById('progress-fill').style.width = pct + "%";
        document.getElementById('percent-text').innerText = pct + "%";
    }

    function gameLoop(t) {
        if(state.mode !== "PLAYING") return;
        accumulator += (t - lastTime) / 1000; lastTime = t;
        while(accumulator >= TICK) { updatePhysics(); accumulator -= TICK; }
        draw(); requestAnimationFrame(gameLoop);
    }
</script>
</body>
</html>
